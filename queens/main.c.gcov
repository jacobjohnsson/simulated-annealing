        -:    0:Source:src/main.c
        -:    0:Graph:bin/main.gcno
        -:    0:Data:bin/main.gcda
        -:    0:Runs:1
        -:    1:#include <math.h>
        -:    2:#include <stdbool.h>
        -:    3:#include <stdio.h>
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include <time.h>
        -:    7:
        -:    8:static const int BOARD_SIZE = 40;
        -:    9:static const double FREEZE_POINT = 0.0001;
        -:   10:
        -:   11:/* return a random number in [min, max] */
        -:   12:int
   393566:   13:xrand(int min, int max)
        -:   14:{
   393566:   15:  return rand() / (RAND_MAX / (max - min)) + min;
        -:   16:}
        -:   17:
        -:   18:typedef struct _solution {
        -:   19:  char *board;
        -:   20:  int size;
        -:   21:  int fitness;
        -:   22:} solution;
        -:   23:
        -:   24:solution *
   196403:   25:solution_new(int board_size)
        -:   26:{
   196403:   27:  solution *s = malloc(sizeof(solution));
   196403:   28:  s->board = calloc(sizeof(char), board_size);
   196403:   29:  s->size = board_size;
   196403:   30:  s->fitness = -1;
        -:   31:
   196403:   32:  return s;
        -:   33:}
        -:   34:
        -:   35:void
   196403:   36:solution_free(solution *s)
        -:   37:{
   196403:   38:  free(s->board);
   196403:   39:  free(s);
   196403:   40:}
        -:   41:
        -:   42:void
       20:   43:solution_randomize(solution *s)
        -:   44:{
      820:   45:  for (int i = 0; i < BOARD_SIZE; i++) {
      800:   46:    s->board[i] = xrand(0, BOARD_SIZE);
        -:   47:  }
       20:   48:}
        -:   49:
        -:   50:solution *
   196383:   51:solution_random_successor(solution *s)
        -:   52:{
   196383:   53:  solution *next = solution_new(BOARD_SIZE);
   196383:   54:  memcpy(next->board, s->board, next->size * sizeof(char));
        -:   55:
   196383:   56:  int column = xrand(0, next->size);
   196383:   57:  int new_row = xrand(0, next->size);
   196383:   58:  next->board[column] = new_row;
        -:   59:
   196383:   60:  return next;
        -:   61:}
        -:   62:
        -:   63:/* [0 3 3 2 1 ]
        -:   64: * [. . . . . ]
        -:   65: * [. Q Q . . ]
        -:   66: * [. . . Q . ]
        -:   67: * [. . . . Q ]
        -:   68: * [Q . . . . ]
        -:   69: */
        -:   70:
        -:   71:int
   589185:   72:solution_fitness(solution *s)
        -:   73:{
        -:   74:  /* BOARD_SIZE - n queens that see eachother */
   589185:   75:  int sum = 0;
        -:   76:
   589185:   77:  if (s->fitness != -1) {
   392782:   78:    return s->fitness;
        -:   79:  }
        -:   80:
        -:   81:  /* check same row */
  7856120:   82:  for (int col = 0; col < s->size - 1; col++) {
160854057:   83:    for (int j = col + 1; j < s->size; j++) {
153194340:   84:      if (s->board[col] == s->board[j]) {
   573517:   85:        sum += 1;
        -:   86:      }
        -:   87:    }
        -:   88:  }
        -:   89:
        -:   90:  /* check up diagonal */
  7856120:   91:  for (int col = 0; col < s->size - 1; col++) {
160854057:   92:    for (int j = col + 1; j < s->size; j++) {
153194340:   93:      if (s->board[col] + j - col == s->board[j]) {
   211567:   94:        sum += 1;
        -:   95:      }
        -:   96:    }
        -:   97:  }
        -:   98:
        -:   99:  /* check down diagonal */
  7856120:  100:  for (int col = 0; col < s->size - 1; col++) {
160854057:  101:    for (int j = col + 1; j < s->size; j++) {
153194340:  102:      if (s->board[col] - (j - col) == s->board[j]) {
   210636:  103:        sum += 1;
        -:  104:      }
        -:  105:    }
        -:  106:  }
        -:  107:
   196403:  108:  s->fitness = sum;
        -:  109:
   196403:  110:  return sum;
        -:  111:}
        -:  112:
        -:  113:void
       40:  114:solution_print(solution *s)
        -:  115:{
       40:  116:  printf("[");
     1640:  117:  for (int i = 0; i < s->size; i++) {
     1600:  118:    printf("%d ", s->board[i]);
        -:  119:  }
       40:  120:  printf("]: %d\n", solution_fitness(s));
       40:  121:}
        -:  122:
        -:  123:double
   196401:  124:cooling_schedule (int step) {
   196401:  125:  return 1.0 / (step);
        -:  126:}
        -:  127:
        -:  128:bool
   195591:  129:gamble(int diff, double temperature)
        -:  130:{
   195591:  131:  double d = (double)diff;
   195591:  132:  return (double)rand() / RAND_MAX < temperature * 1/diff;
        -:  133:}
        -:  134:
        -:  135:solution *
       20:  136:simulated_annealing(solution *initial)
        -:  137:{
       20:  138:  solution *current = initial;
        -:  139:  solution *next;
        -:  140:  double temperature;
        -:  141:  double diff;
        -:  142:  int t;
        -:  143:
       20:  144:  for (t = 1; ; t++) {
   196401:  145:    temperature = cooling_schedule(t);
   196401:  146:    if (temperature < FREEZE_POINT) {
       18:  147:      break;
        -:  148:    }
        -:  149:
   196383:  150:    next = solution_random_successor(current);
   196383:  151:    if (solution_fitness(next) == 0) {
        2:  152:      solution_free(current);
        2:  153:      current = next;
        2:  154:      break;
        -:  155:    }
        -:  156:
   196381:  157:    diff = solution_fitness(next) - solution_fitness(current);
   196381:  158:    if (diff < 0) {
      790:  159:      solution_free(current);
      790:  160:      current = next;
   195591:  161:    } else if (gamble(diff, temperature)) {
     9823:  162:      solution_free(current);
     9823:  163:      current = next;
        -:  164:    } else {
   185768:  165:      solution_free(next);
        -:  166:    }
        -:  167:  }
        -:  168:
       20:  169:  printf("iterations: %d\n", t);
        -:  170:
       20:  171:  return current;
        -:  172:}
        -:  173:
        1:  174:int main(int argc, char *argv)
        -:  175:{
        -:  176:  //srand(42);
        1:  177:  srand(time(NULL));
        -:  178:
       21:  179:  for (int i = 0; i < 20; i++) {
        -:  180:
       20:  181:    solution *initial = solution_new(BOARD_SIZE);
       20:  182:    solution_randomize(initial);
       20:  183:    printf("Initial board:\n");
       20:  184:    solution_print(initial);
       20:  185:    solution *s = simulated_annealing(initial);
        -:  186:
       20:  187:    printf("Final board:\n");
       20:  188:    solution_print(s);
        -:  189:
       20:  190:    solution_free(s);
        -:  191:
        -:  192:  }
        -:  193:
        1:  194:  return 0;
        -:  195:}
